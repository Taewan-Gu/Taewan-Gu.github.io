---
sidebar_position: 3
description: 파이썬 클린코드 챕터 3 요약
---

# Ch.03 좋은 코드의 일반적인 특징

## 계약에 의한 디자인(DbC)

소프트웨어는 다른 레이어나 컴포넌트들 간에 교류하는 경우, 서로에 대한 계약이 필요할 수 있다. 이는 사전조건이 성립해야 해당 기능의 제대로 된 결과를 받을 수 있다는 것을 말한다. 사전조건이 맞지 않는 경우, Error를 발생시키고 올바른 예외 타입(커스텀 예외 처리도 포함)을 사용할 것을 권장한다.

* 사전조건: 코드가 실행되기 전에 해당 기능에 제공된 어떠한 데이터들의 유효성이 맞는지 확인
* 사후조건: 기대한 반환 값이 맞는지 확인
* 불변식: 해당 기능에서 일정하게 유지되어야 할 로직, docstring에 넣어두곤 한다.
* 부작용: 코드 상의 부작용, docstring에 넣어두곤 한다.

<br/>

## 방어적 프로그래밍

코드의 모든 부분을 유효하지 않은 것으로 부터 스스로 보호할 수 있게 한다. 예상할 수 있는 시나리오의 오류를 에러 핸들링하고 발생하지 않아야 하는 오류는 Assertion 으로 처리한다. Assertion 을 쓸 때는 예외를 절대 그냥 넘겨서는 안 된다. 기능을 중단하든, 에러 메세지를 로깅이나 알림으로 개발자에게 알리든 어떠한 조치를 취하는 것을 매우 권장한다. 이는 발생하지 않아야 하는 오류를 소프트웨어 개선에 활용하기 위함이다.

### 에러 핸들링

에러 핸들링 시, 에러가 날 상황을 값 대체로 통해 통제하는 방법이 있으며, 예외 처리를 통해 통제하는 경우가 있다. 값 대체는 말 그대로 에러가 날 만한 값들을 안전한 값들로 변경하는 것이다. 그리고 예외 처리는 해당 예외가 일어날 때, 어떠한 처리를 해줄지 개발자가 코드상으로 아예 알려주는 것이다.


:::caution
_**예외 처리 시 주의 점**_

* 올바른 수준의 추상화 단계에서 예외 처리
* 엔드 유저에게 Traceback 노출 금지
* 비어있는 except 블록 지양
* 원본 예외 포함

> 다른 부분은 바로 이해 가능하지만 `올바른 수준의 추상화 단계에서 예외 처리`는 예제를 확인해보자.
>
> ```python
> def function1(x):
>     try:
>         # 로직 작업 생략
>         function2(x)
>     except ValueError:
>         print("function1 Error")
>     except TypeError:
>         print("function2 Error")
> 
> 
> def function2(x):
>     # 로직 작업 생략
>     pass
> 
> 
> function1(1)
> ```
>
> 위의 코드와 같이 다른 함수의 Error를 상위 함수에서 처리해버리면 안 된다는 것이다.
:::

<br/>

## 관심사의 분리

응집력이 높고 결합력이 낮은 디자인을 만들어야 한다. 이를 통해 함수의 재사용성을 높이고, 파급효과를 줄이며, 함수의 추상화 수준을 맞추어야 한다.

:::note
높은 추상화는 높은 추상화를 가지는 코드로 가져가는 것이 옳고, 낮은 추상화는 낮은 추상화를 가지는 코드로 가져간다. 높은 추상화는 함수 안에 여러 함수를 실행시키는 것을 예로 들 수 있고, 낮은 추상화는 기본 연산하는 것을 들 수 있다.

참고: https://lordofkangs.tistory.com/m/127
:::

<br/>

## 개발지침 약어

**DRY/OAOO - 중복을 피하라.**

* 개발 비용 상승
* 수정 시, 오류 발생 증가
* 신뢰성 하락

**YAGNI - 미래에 필요할 것을 염두하지 마라.**

* 개발 비용 상승
* 코드 이해 어려움과 동작 에러 증가

**KIS - 간단하게 하라**

* 확장 고려 시, 개발 비용 상승
* 짧은 코드가 무조건 좋은 것은 아니다.

**EAFP/LBYL - 먼저 만들고 오류를 고쳐라/미리 살펴라**

* 둘은 상반되는 개발 지침으로 상황에 맞게 사용

<br/>

## 다중 상속

파이썬은 다중 상속을 지원하는데, 이는 양날의 검이다. 메서드가 중복되면 한 메서드만 쓰이기 때문이고, 이 때문에 예기치 않은 에러가 발생할 수 있다.

### 메서드 결정 순서

다중 상속받는 두 개의 클래스에서 같은 변수가 지정되어 있다면 C3 linearization 또는 MRO 라는 알고리즘을 사용하여 이를 해결한다. 이 알고리즘은 메서드가 호출되는 방식을 정의하는데, 밑의 명령어를 통해 결정 순서를 직접 확인 할 수도 있다.

``` python
print([cls.__name__ for cls in dummyObject.mro()])
```

### 믹스인

믹스인은 코드를 재사용하기 위해 일반적인 행동을 캡슐화 해놓은 부모 클래스이며, 믹스인 클래스 자체만으로는 유용하지 않고 대부분 다른 클래스의 메서드나 속성에 결합하여 사용된다.

<br/>

## 함수와 메서드의 인자

### 가변인자

패킹과 언패킹을 통해서 여러 가변인자를 표현할 수 있다. 먼저 언패킹은 `first, second = [1, 2]` 와 같이 이터러블 객체를 풀어쓰는 것을 말한다. 여기서 풀어 쓸 때는 `first, *rest = [1, 2, 3]` 와 같이 부분적으로 언패킹도 가능하다.

이중 별표 가변인자 사용법으로는 `function(**{"key": "value"})` 가 `function(key="value")` 와 동일하다. 이는 밑과 같이 반대로 사용할 수도 있다.

``` python
def function(**kwargs):
    print(kwargs)


function(key="value")

# 응답
{'key': 'value'}
```



### 위치 전용 인자

위치 전용 인자는 `/` 키워드를 맨 마지막 파라미터로 넣어서 키워드 인자를 사용하지 못하게 하는 방법이다. 예시는 밑과 같다.

``` python
def function(x, y, /):
    print(f"{x} {y}")


function(1, 2) # 가능
function(x=1, y=2) # 불가능
```



### 키워드 전용 인자

가변 인자 뒤에 넣은 인자는 키워드 전용 인자가 된다. 이런 키워드 전용 인자 같은 경우는 특별히 명시를 해주어야 하는 상황이 있는 함수에 사용한다.

``` python
def function(x, y, *args, kw1, kw2):
    print(f"{x} {y} {kw1} {kw2}")


function(1, 2, kw1=1, kw2=2)

# 응답
1 2 1 2
```



### 함수 인자의 개수

함수 인자의 개수는 적절히 사용해야 한다. 인자가 너무 많게 되면 가독성이 떨어지고 호출 함수와의 결합력이 커지며, 해당 함수는 추상화가 덜 되었다는 것을 의미한다. 그렇다면 해당 인자들을 객체로 만들어서 넘기는 것이 옳다. 하지만 이렇게 변경가능한 객체를 넘길 때는 주의 해야한다. 해당 객체의 데이터를 변경 시에는 데이터 오염이 일어날 수 있기 때문이다.

<br/>
