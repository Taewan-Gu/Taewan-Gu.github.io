---
sidebar_position: 9
description: 파이썬 클린코드 챕터 9 요약
---

# Ch.09 일반적인 디자인 패턴

:::note
파이썬에서는 디자인 패턴이 이미 보이지 않는 부분에서 구현되어 있고, 이 때문에 디자인 패턴에 종속되어 쓰지 말자는 이야기가 있다. 하지만 이 책에서 디자인 패턴을 배워야 하는 이유는 의사소통에 있어 중요한 부분을 차지하고 있기 때문이라고 한다. 디자인 패턴을 구현하지 않더라도 이 부분은 이러한 디자인 패턴과 비슷하다는 형식으로 말할 수 있기 때문에 파이썬을 쓰는 개발자도 배워둘 필요가 있다.
:::

<br/>

## 생성 패턴

### 싱글톤(Singleton) 패턴

싱글톤 패턴은 시스템 상에 해당 클래스의 객체가 무조건 하나만 가지는 것을 말한다. 하지만 파이썬에서는 싱글톤 패턴을 지양한다. 이유는 밑과 같다.

1. 파이썬은 모든 것이 객체이다.
2. 단위 테스트가 어렵다.

그렇다면 어떻게 해야하나?

파이썬에는 `sys.modules`이라는 존재가 있다. 여기서 `import` 에 해당하는 패키지, 라이브러리 등을 먼저 찾기 때문에 여기에 객체를 저장하면 싱글톤으로 사용할 수 있다.



### 모노스테이트(Monostate) 패턴

모든 변수를 클래스 변수로 지정한 패턴이다. 상태는 유지할 수 있지만, 객체는 여러 개를 생성해낸다.



### 빌더(Builder) 패턴

빌더 패턴은 우리가 `Spring`을 사용한다면 흔히 볼 수 있는 패턴이다. 밑에 `Java`예제를 보면 `.` 으로 이어지며 마지막에 빌딩하는 것을 볼 수 있다.

```java
kafka = kafkaBuilder.setSource(dummySource)
					.setConsumer(dummyLoader)
					.build();
```

이 패턴은 정말 잘 사용되고 개발할 때 매우 유용하다.

<br/>

## 구조 패턴

### 어댑터(Adapter) 패턴

이름 그대로의 뜻을 가지고 있다. 기존의 코드를 재사용하기 위해 내외적으로 구조를 변환하는 작업을 한다.

예를 들어, 어떤 레거시 코드를 가진 시스템의 API를 사용해야 한다. 하지만 해당 API 응답으로는 현재 작성 중인 시스템에 사용할 수가 없다. 이 때, 어댑터 패턴을 이용하여 응답을 받아 현재 작성 중인 시스템에 사용할 수 있도록 변경해준다. 전력 어댑터를 생각하면 매우 편하게 이해할 수 있다.



### 데코레이터(Decorator) 패턴

하위 클래스가 데코레이터 패턴을 사용할 메서드에 새로운 기능을 하나씩 덧입히는 것이다. 파이썬은 다른 언어와 다르게 덕타이핑이 가능하므로 이를 쉽게 구현할 수 있다.

```python
class a:
    def do(self): 
        return 1


class b(a):
    def do(self):
        super().do()
        ...
        return 1


class c(b) : 
    def do(self):
        super().do()
        ...
        return 1
```



### 파사드(Facade) 패턴

파사드 패턴은 저수준 인터페이스들을 고수준의 인터페이스로 만드는 것이다.

예를 들면, 커피 만드는데 필요한 것들(원두, 원두그라인더, 드립주전자, 제빙기)이 있다면 이것을 기계에 모은다. 커피 기계에는 버튼만 누르면 바로 커피를 마실 수 있게 되는 것과 같다. 자, 그러면 밑과 같은 느낌의 코드가 만들어진다.

```python
class 바리스타:
	커피만들기(커피기계)

class 커피기계(ABC):
	커피제조()

class 커피기계구현체:
	var 원두
	var 원두그라인더
	var 드립주전자
	var 제빙기
	커피제조()
```



이렇게 되면 좋은 점은 바리스타는 커피기계 버튼만 누르면 된다는 점이지만, 단점으로는 커피기계 구현체가 복잡해질 가능성이 있다는 점이다. 그러므로 매일 말하는 거지만 적절하게 잘 사용하는 개발자의 능력이 제일 중요하다.

<br/>

## 행위 패턴

### 책임 연쇄(Chain of Responsibility) 패턴

말 그대로 책임을 연쇄적으로 가지게 된다. 어떠한 핸들러가 하나의 책임을 가지고 있다면, 이 책임을 다음 핸들러에게 넘겨 그 핸들러가 책임지도록 만드는 것이다.

예를 들어, 로그인 시에 `로그인 -> 비밀번호 암호화 -> ID 체크 -> 전달된 암호화 코드와 해시화된 암호 확인 -> 로그인 성공` 순으로 이어질 때, 사실 비밀번호 암호화와 ID 체크는 동시에 일어날 수 있다. 하지만 책임 연쇄 패턴에서는 책임을 연쇄시키지 분할시키지 않는다. 그만큼 책임질 것들이 많아지기 때문이다. 이렇게 단순한 것은 동시에 해도 문제가 없겠지만, 여러 복잡한 시스템에서는 책임을 분할시키는 순간 프로그래밍할 때 더 확인해야 하고, 쉽게 리팩토링할 수 있는 부분들이 적어진다. 그러므로 하나의 책임을 전가시키는 방법을 택한 것이 책임 연쇄 패턴이라 볼 수 있다.



### 템플릿 메서드(Template Method) 패턴

부모 클래스에서 메서드 순서를 정해놓고 그 메서드를 자식 클래스들이 구현하는 것을 일컫는다. 디폴트로 각 단계에 따른 메서드가 만들어져 있을 수도 있고,  없을 수도 있다.

예를 들어, 가게의 하루 일과가 `open -> selling -> cleaning -> close` 라고 한다면 부모 클래스에 해당 메서드를 순서대로 실행시키는 메서드를 만든다. 그리고 자식 클래스들은 해당 메서드를 구현하면 되는 것이다.

```python
class store():
  def do():
    open()
    selling()
    cleaning()
    close()
  
  def open()
  def selling()
  def cleaning()
  def close()


class goods_store(store):
  def open():
    ...
  def selling():
    ...
  def cleaning():
    ...
  def close():
    ...
```



### 상태(State) 패턴

상태 패턴은 매우 유명한 예가 있다. 바로 `다크모드` 이다. `class` 변수의 `state`에 따라 모든 화면의 색이 바뀐다. 이처럼 `open`, `close` 처럼 상태를 설정할 수도 있고, 그에 따라 해당 객체에서 사용할 수 있는 메서드와 메서드의 결과가 달라진다.

<br/>

## Null 객체 패턴

메서드의 반환 값은 모두 일정해야 한다. 책을 보니 타입을 하나의 타입만 일정하게 나오게 하라는 뜻인듯 하다.

1. 런타임 오류 발생 하락
2. 객체 유용하게 사용 가능
3. 코드 테스트가 쉬움
4. 디버깅에 도움이 됨

``` python
# 반환 값이 일정하지 않음. 지양해야 함.
def a() -> int | None:
	return ...

# 반환 값이 일정함. 지향해야 함.
def b() -> int:
	return ...
```

:::note
_**사견**_

위에서 None을 쓰지 말라하는데, 내 생각은 좀 다르긴 하다. 예를 들어서 User가 없는데 None 값이 아닌 디폴트 값을 반환했다고 하자, 그러면 디폴트 값은 이미 암묵적인 규약이 되어 버린다. 많은 객체가 생길텐데, 각각마다 암묵적인 규약을 만든다는 것은 실제 코딩에서는 어려운 일이라 생각한다. 그럴경우 그냥 None 을 쓰는게 좋지 않을까?
:::

<br/>