---
sidebar_position: 1
description: Top Interview 150 | 문제 1 - 9
---

# 문제 1 - 9

## 88. Merge Sorted Array

:::note
### 문제 요약

* 정렬된 두 리스트 `nums1`, `nums2`가 주어지고 `nums1`에 `nums2`를 병합하여 정렬하라.
* `nums1` 리스트에는 `nums2`의 길이 만큼 0이 추가로 채워져 있다.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/merge-sorted-array/)
:::

<br/>



#### 첫 번째 시도 ✅

* `nums1` 리스트에 `nums2` 길이 만큼 뒤에서 부터 없앤다. (0이 추가로 채워져 있는 것을 없앰.)
* `nums2` 리스트를 `nums1`으로 삽입한다.
* `num1` 리스트를 정렬한다.

```ts
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    for (let i=0; i<n; i++) {
        nums1.pop()
    }
    for (let i=0; i<n; i++) {
        nums1.push(nums2[i])
    }

    nums1.sort((a,b) => a - b)
};
```



<br/>



#### 두 번째 시도 ✅

* `nums1` 리스트에 추가로 채워져 있는 부분에 `nums2`을 넣어준다.
* `num1` 리스트를 정렬한다.

```ts
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    for (let i=0; i<n; i++) {
        nums1[m+i] = nums2[i]
    }

    nums1.sort((a,b) => a - b)
};
```



<br/>



#### 세 번째 시도 ✅

* 정렬된 리스트라는 점을 이용하여 각 리스트에서 제일 큰 숫자를 하나씩 빼온다.
* `nums1`의 알맞은 자리에 넣어준다.

```ts
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    let [i, j, k] = [m-1, n-1, n+m-1]
    while (k > -1) {
        if (i > -1 && nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--]
        } else if (j > -1) {
            nums1[k--] = nums2[j--]
        } else {
            break
        }
    }
};
```



<br/>

---

## 27. Remove Element

:::note

### 문제 요약

* 주어진 리스트에서 특정 값을 빼고 남은 리스트의 길이를 반환하라.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/remove-element/)

:::



<br/>


#### 첫 번째 시도 ✅

* 리스트를 필터링해서 필터링한 값을 `nums` 리스트의 알맞은 위치에 넣어준다.
* 필터링된 리스트의 길이를 반환한다.

```ts
function removeElement(nums: number[], val: number): number {
    const filtered = nums.filter(x => x !== val)
    for (let i=0; i<filtered.length; i++) {
        nums[i] = filtered[i]
    }
    
    return filtered.length
};
```



<br/>



#### 두 번째 시도 ✅

* 리스트에 삽입할 인덱스를 지정해두고 `nums` 리스트를 순회하며 타겟 숫자가 아닐 경우 삽입할 인덱스에 하나씩 삽입한다.
* 삽입 후, 삽입할 인덱스를 1씩 올린다.
* 삽입할 인덱스를 반환하면 삽입했던 수를 반환할 수 있다.

```ts
function removeElement(nums: number[], val: number): number {
    let j = 0
    for (const num of nums) {
        if (num !== val) {
            nums[j++] = num
        }
    }
    
    return j
};
```



<br/>

---

## 26. Remove Duplicates from Sorted Array

:::note

### 문제 요약
* 주어진 정렬된 리스트에서 중복된 값을 빼고 남은 리스트의 길이를 반환하라.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

:::

<br/>

#### 첫 번째 시도 ✅

* 리스트에 삽입할 인덱스와 이전 값을 저장할 변수(`before`)를 지정해 둔다.
* `nums` 리스트를 순회하며 현재 값과 `before`이 같다면 삽입할 인덱스에 삽입한다.
* 삽입 후, 삽입할 인덱스를 1씩 올리고, 삽입을 하지 않더라도 `before`에 현재 값을 저장하고 다음 순회로 넘어간다.
* 삽입할 인덱스를 반환하면 삽입했던 수를 반환할 수 있다.

```ts
function removeDuplicates(nums: number[]): number {
    let j = 0
    let before = null
    for (const num of nums) {
        if (num !== before) {
            nums[j++] = num
        }
        before = num
    }
    
    return j
};
```



<br/>



#### 더 나아가기

* `before` 이 아니라 그냥 이전 인덱스의 값과 비교해도 무방하다.



<br/>

---

## 80. Remove Duplicates from Sorted Array II

:::note
### 문제 요약

* 주어진 정렬된 리스트에서 3개 이상 중복된 값을 빼고 남은 리스트의 길이를 반환하라.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)

:::

<br/>

#### 첫 번째 시도 ✅

* 리스트에 삽입할 인덱스와 현재 값이 있었다는 확인을 할 Object를 선언한다.
* `nums` 리스트를 순회하며 현재 값에 대한 `visit[현재 값]` 값이 없다면 0으로 초기화시켜주고 `visit[현재 값]`이 2보다 작다면 삽입할 인덱스에 현재 값을 삽입해준다.
* 삽입 후, 삽입할 인덱스를 1씩 올리고, `visit[현재 값]`을 1씩 올려준다.
* 삽입할 인덱스를 반환하면 삽입했던 수를 반환할 수 있다.

```ts
function removeDuplicates(nums: number[]): number {
    let j = 0
    let visit = {}
    for (const num of nums) {
        if (!visit[num]) {
            visit[num] = 0
        }
        if (visit[num] < 2) {
            visit[num]++
            nums[j++] = num
        }
    }
    
    return j
};
```



<br/>


---

## 169. Majority Element

:::note
### 문제 요약
* 주어진 리스트에서 `리스트의 길이/2` 보다 큰 개수를 가진 숫자를 반환하라.

<br/>


[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/majority-element/)
:::



<br/>

#### 첫 번째 시도 ✅

* 현재 값이 있었다는 확인을 할 Object(`visit`)를 선언한다.
* `nums` 리스트를 순회하며 현재 값에 대한 `visit[현재 값]` 값이 없다면 0으로 초기화시켜주고 `visit[현재 값]`에 1을 더해준다.
* `visit[현재 값]`이  `리스트의 길이/2` 보다 크다면 해당 숫자를 반환한다.

```ts
function majorityElement(nums: number[]): number {
    const visit = {}
    for (const x of nums) {
        if (!visit[x]) {
            visit[x] = 0
        }
        visit[x]++
        if (visit[x] > nums.length/2) {
            return x
        }
    }
};
```



<br/>



#### 두 번째 시도 ✅

* 정렬을 이용해서 n/2 번째의 값을 리턴하는 방법도 있다.

```ts
function majorityElement(nums: number[]): number {
    nums.sort((a,b) => a-b)
    return nums[Math.floor(nums.length/2)]
};
```



<br/>

---

## 189. Rotate Array

:::note
### 문제 요약

* 주어진 리스트의 맨 앞의 값을 맨 뒤로 옮기는 행동을 `k` 하라.

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/rotate-array/)
:::


<br/>

#### 첫 번째 시도 ✅

* `k`를 `nums` 길이로 나눈 나머지(`mod`)를 구한다.
*  `nums` 길이에서 `mod`를 뺀 만큼의 값들을 잠시 모아둔다.
* `nums`에 삽입할 인덱스를 0으로 선언해놓는다.
* `nums` 길이에서 `mod`를 뺀 값을 시작으로 `nums` 길이 + `nums` 길이에서 `mod`를 뺀 값까지 순회한다.
* 해당 순회에서 `i`가 `nums` 길이보다 작으면 삽입할 인덱스에 `nums` 값에서 바로 찾아 넣어주고, 그보다 크다면 `filteredNums`에 잠시 모아둔 값을 활용하여 삽입할 인덱스에 값을 넣어준다. (해당인덱스는 `nums` 길이보다 크므로 나머지 연산을 통해 `filteredNums` 인덱스를 구한다.)
* 삽입하였다면 삽입할 인덱스의 값에 1을 더해준다.

```ts
function rotate(nums: number[], k: number): void {
    const len = nums.length
    const mod = k%len
    const filteredNums = nums.filter((_,i) => i<len-mod)
    let idx = 0
    for (let i=len-mod; i<2*len-mod; i++) {
        if (i < len) {
            nums[idx++] = nums[i]
        } else {
            nums[idx++] = filteredNums[i%len]
        }
    }
};
```



<br/>



#### 더 나아가기

* 첫 번째 시도에서 순회방향을 문제에 맞게 반대로 만들어도 풀린다.
* Deque를 구현하여 풀어도 된다. (파이썬에는 기본적으로 장착되어 있지만 TS에는 없어서 아쉽다.)
* Object(HashMap or Dictionary)로 체크하며 풀어도 될 듯하다.



<br/>

---

## 121. Best Time to Buy and Sell Stock

:::note
### 문제 요약

* 주식가격이 주어진 리스트가 있고 각 인덱스는 날짜라고 볼 수 있다.
* 최소 가격으로 사서 미래에 최대 가격으로 팔 수 있는 기댓값을 구하여라.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

:::

<br/>

#### 첫 번째 시도 ✅

* 이전 날짜까지 포함하여 작은 값을 `min`이라는 변수에 저장해둔다.
* 리스트 순회를 하며 현재 값이 `min`보다 작은 값은 `min`에 저장하고 현재 값에서 `min` 값을 뺀다.
* 뺀 값 중 제일 큰 숫자를 반환한다.

```ts
function maxProfit(prices: number[]): number {
    let min = prices[0]
    let ans = 0
    for (const price of prices) {
        if (min > price) {
            min = price
        }
        ans = Math.max(price - min, ans)
    }

    return ans
};
```



<br/>



#### 두 번째 시도 ✅

* `Math.min`을 사용하고 리팩토링하여 좀 더 깔끔한 코드를 만들어 보았다.

```ts
function maxProfit(prices: number[]): number {
    let [min, ans] = [prices[0], 0]
    for (const price of prices) {
        min = Math.min(min, price)
        ans = Math.max(price - min, ans)
    }
    return ans
};
```



<br/>

---

## 122. Best Time to Buy and Sell Stock II

:::note

### 문제 요약

* 주식가격이 주어진 리스트가 있고 각 인덱스는 날짜라고 볼 수 있다.
* 최소 가격으로 사서 미래에 최대 가격으로 팔 수 있으며, 횟수에는 제한이 없다.
* 최대 이익을 구하여라.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

:::

<br/>

#### 첫 번째 시도 ✅

* 주어진 리스트의 첫 번째 값을 `min`이라는 변수에 저장해둔다.
* 리스트 순회를 하며 현재 값이 `min`보다 크다면 두 값의 차를 결과값에 더하고 `min` 값을 현재 값으로 업데이트한다.
* 현재 값이 `min`보다 작다면 `min` 값을 현재 값으로 업데이트만 한다.
* 순회가 끝나면 결과값을 반환한다.

```ts
function maxProfit(prices: number[]): number {
    let [min, ans] = [prices[0], 0]
    for (const price of prices) {
        if (min < price) {
            ans += price - min
        }
        min = price
    }
    return ans
};
```



<br/>



#### 두 번째 시도 ✅ 🤙🏻

* 더 이상 코드를 개선할 방안이 생각나지 않아 찾아보니 `Math.max`를 사용하여 이전 값과 비교한 값이 0보다 크다면 결과 값에 더하는 것으로 리팩토링할 수 있었다.

```ts
function maxProfit(prices: number[]): number {
    let ans = 0
    for (let i=1; i<prices.length; i++) {
        ans += Math.max(0, prices[i]-prices[i-1])
    }
    return ans
};
```



<br/>

---

## 55. Jump Game

:::note

### 문제 요약

* 주식가격이 주어진 리스트가 있고 각 인덱스는 날짜라고 볼 수 있다.
* 최소 가격으로 사서 미래에 최대 가격으로 팔 수 있으며, 횟수에는 제한이 없다.
* 최대 이익을 구하여라.

<br/>

[**🧑🏻‍💻 LeetCode 문제 풀러가기**](https://leetcode.com/problems/jump-game/)

:::



<br/>

#### 첫 번째 시도 ✅

* 주어진 리스트의 첫 번째 값을 `canJump`이라는 변수에 저장해둔다.
* 이 변수는 점프할 수 있는 최대 칸을 뜻한다. 그러므로 이 변수를 현재 값과 비교하여 계속 업데이트 해나간다.
* 점프를 할 수 없게 되면 `false`를 반환하고 리스트 순회가 성공적으로 마치면 `true`를 반환한다.

```ts
function canJump(nums: number[]): boolean {
    let canJump = nums[0]
    for (let i=1; i<nums.length; i++) {
        if (canJump <= 0) {
            return false
        }
        canJump = Math.max(nums[i], canJump-1)
    }

    return true
};
```



<br/>



#### 두 번째 시도 ✅

* 거꾸로 하는 방법도 있다.
* 도착지에서 부터 출발지까지 가능한지 확인하며, `arrival`이 출발지인 0에 도착할 수 있으면 `true`를 반환한다.

```ts
function canJump(nums: number[]): boolean {
    let arrival = nums.length-1
    for (let i=nums.length-2; i>-1; i--) {
        if (i+nums[i] >= arrival) {
            arrival = i
        }
    }

    return arrival ? false : true
};
```

<br/>
