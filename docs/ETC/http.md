---
description: http 관련된 지식들을 알아보자
---

# HTTP

## 사전 학습

* 인터넷 상에서 컴퓨터는 어떻게 통신을 할까? 
  * 복잡한 인터넷 망을 통한 서버와 클라이언트의 소통이다.
* IP는 무엇일까?
  * IP는 서버와 클라이언트의 목적지를 정하는 어떠한 규칙이다.
  * 간단히 말해, 출발지, 목적지, 내용을 넣은 패킷을 인터넷 노드 망을 통해 목적지에 도착하게 된다.
  * 목적지는 결과 패킷을 출발지에 다시 보내게 된다.(다른 새로운 목적지로 보낼 수도 있음.)
  * 비신뢰성(패킷 손실, 패킷 순서 변경), 비연결성(단 방향), 한 IP의 여러 어플리케이션 동작(포트 필요) 등 한계가 존재한다.
* TCP, UDP가 왜 필요할까?
  * IP의 한계 때문 
  * IP는 네트워크 계층(3)
  * TCP, UDP는 전송 계층(4)
  * TCP: IP의 한계인 비신뢰성, 비연결성, 한 IP의 여러 어플리케이션 동작의 한계를 없앤다.
    * 가상회선 패킷 방식. 패킷 재전송 요청 때문에 스트리밍 서비스에 불리하다.
    * 흐름제어, 혼잡제어도 한다. 연결형(서로 연결해서 보내기) 이다.
    * 3-way 핸드쉐이킹(연결 시작), 4-way 핸드쉐이킹(연결 종료)을 한다.
    * 흐름 - 수신측에서 감당할 수 있는지 측정
    * 혼잡 - 네트워크 내의 패킷 수 측정
  * UDP: IP의 한계인 비신뢰성(데이터의 신뢰까지만 ex. 체크섬), 한 IP의 여러 어플리케이션 동작의 한계를 없앤다.
    * 데이터그램 패킷 방식. 속도는 빠른데 UDP 헤더의 체크섬 필드를 통해 최소한의 오류만을 검출한다.
    * 비연결형(걍 보내기) 이다. 어플리케이션 단에서 좀 더 커스터마이징 가능하다.
  * 신뢰성은 TCP가 높지만 속도는 UDP가 우수하다.

* PORT란?
  * 같은 IP내에서 각 어플리케이션에 지정해서 응답하게 해주는 것
  * IP는 아파트, PORT는 몇동 몇호
* DNS는 왜 필요할까?
  * IP는 바뀔 수 있다.
  * 도메인명을 지정해서 IP를 지정해줄 수 있다.
  * DNS 서버가 도메인명과 IP를 연락처처럼 연동시켜놓는다.

* URI(Uniform Resource Identifier)
  * 자원이 어딨는지 식별하는 것 - URL, URN이 있다.
  * URN은 aaa:aaa:aaa:123 이런 형식으로 `:`를 활용해서 식별한다. 하지만 요즘은 사용 X
  * URL(Uniform Resource Locator)
    * URI와 뒤의 리소스 경로, 쿼리 등을 포함한 주소
    * 예제) scheme://[userinfo@]host[:port]/path?query#fragment
    * 다른 부분은 다 알테지만 fragment는 색다르니까 간단히 설명하자면 서버에 보내는 것이 아닌 해당 html에서 쓰려고 만든 것.

* 웹 브라우저의 요청 흐름
  * HTTP 요청 메세지를 보내면 소켓라이브러리를 통해 전송, 네트워크 ... 물리 계층을 지나 인터넷 망으로 패킷이 들어간다. 해당 패킷은 서버에서 반대로 어플리케이션 계층까지 올라가 해당 요청을 수행하고 결과를 똑같은 방법으로 응답한다.



## BASIC

* HTTP 버전
  * HTTP/1.1 - 이 부분이 제일 많이 씀
  * HTTP/2, HTTP/3는 성능 개선이 되어있지만 호환불가한 브라우저 많음
  * HTTP/3는 UDP 기반(속도 완전 개선)
    * 구글에서 쓰는 중(1.1, 2, 3을 혼용해서 쓰는중)
    * 네이버(1.1, 2 혼용 중)
* 클라이언트 서버 구조
  * 클라이언트가 서버에 요청을 해서 서버는 요청을 대기하다가 응답을 해준다.
* 무상태 프로토콜(Stateless)
  * Stateless vs Stateful
    * Stateful은 클라이언트 상태를 기억하는 것
    * Stateless는 클라이언트 상태를 기억하지 않는 것
  * 왜 Stateless를 지향하는가?
    * 서버를 쉽게 바꿀 수 있다.
    * 서버 증설이 쉽다. - 스케일 아웃
  * 한계
    * 로그인 등의 상태유지
    * 쿠키, 세션 등을 사용해서 상태 유지를 한다. - jwt, session 인증이 대부분
* 비연결성
  * 필요할 때만 연결하고 바로 끊어버리기 때문에 최소한의 자원 사용(서버자원을 효율적으로 사용가능)
  * 하지만 한 클라이언트에서 지속적으로 서버에 요청을 하는 경우 TCP의 핸드쉐이킹이나 TLS 등의 여러부분들이 계속 사용된다. 그렇기 때문에 이런 비효율적인 부분을 개선하기 위해 HTTP 지속 연결을 해준다. 연결을 어느 시간정도는 끊지 않고 계속 놔두는 것을 의미한다.
  * HTTP/2, HTTP/3에서는 많은 최적화가 일어나서 이 부분들이 많이 극복되었다.
* HTTP 메세지
  * 요청메세지와 응답메세지가 다르다.
  * HTTP 메세지 기본 구조
    * start line
    * header
    * empty line - 진짜 그냥 공백라인
    * message body
  * 요청 메세지 start line
    * method path HTTPver
  * 응답 메세지 start line
    * HTTPver statusCode statusMessage
  * header
    * HTTP 전송에 필요한 모든 부가정보가 들어 있음
    * key: value - key는 대소문자 구분 X, value는 대소문자 구분 O
  * message body
    * 보내거나 받을 데이터 첨부 (모든 데이터 가능)



## METHOD

* my 블로그 정리 참고: https://blog.taewan.link/docs/ETC/http-methods
* API URI 설계할 때는 복수를 권장
* 컨트롤 URI는 POST로 설정(로봇 제어, 배달 현황 변경 등) - 이 때는 URI 패스도 동사로 하는 경우가 있다. 원래는 명사로 지정.
* PATCH는 PUT과 다르다.
  * PUT은 생성하거나 완전히 대체
  * PATCH는 원하는 부분만 대체 - PATCH는 호환 안 되는 경우가 있음
* 참고하면 좋은 URI 설계
  * 문서 - 단일개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
    * 예) /members/100
  * 컬렉션 - 서버가 관리하는 리소스 디렉터리
    * 서버가 리소스의 URI를 생성하고 관리
    * 예) /members
  * 스토어 - 클라이언트가 관리하는 자원 저장소
    * 클라이언트가 리소스의 URI를 알고 관리
    * 예) /files
  * 컨트롤 URI - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
    * 동사 직접 사용
    * 예) /members/{id}/delete



## STATUS CODE

* 기본코드 개념
  * 1xx - 요청이 수신되어 처리중
  * 2xx - 요청 정상 처리
  * 3xx - 요청을 완료하려면 추가 행동 필요
  * 4xx - 클라이언트 오류
  * 5xx - 서버 오류
* 클라이언트가 모르는 상태코드가 나타나면 기본 코드를 참고하여 대분류의 코드를 따라간다.
  * 예) 299이면 맨 앞이 2이기 때문에 요청 정상 처리
* 1xx는 거의 사용하지 않음
* 2xx - 성공
  * 200: OK - 요청 성공
  * 201: Created - 요청 성공으로 서버에 데이터가 생성됨
  * 202: Accepted - 요청은 성공했지만, 서버에서 추가적인 작업이 남아있음
  * 204: No Content - 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음.(쿠팡 상품들 확인해보면 빠르게 확인 가능)
* 3xx - 리다이렉션
  * 리다이렉션에는 영구, 일시, 특수 리다이렉션이 있다.
    * 영구: 클라이언트에게 해당 URL이 영구적으로 바꼈다는 것을 보여줌. 이래서 검색엔진에 301 잘못쓰면 해당 URL 검색효율, 현황 등이 한번에 날라갈 수 있음. ※주의※
    * 일시: 클라이언트에게 해당 URL이 잠시 다른 URL로 쓰고 있다는 것을 보여줌.
  * 301, 302을 주로 쓰고 다른 것은 별로 안 씀.
  * 301: Moved Redirect - 옛날 URL을 쓰지 않고 리다이렉션한 URL만 쓰겠다는 것(영구 리다이렉션)
  * 302: Found - 옛날 것을 쓰는데 잠시 새로운 URL로 쓰면서 있겠다는 것(일시 리다이렉션)
  * 303: See Other - 리다이렉트 시, 처음 요청된 메서드를 무조건 리다이렉션 요청에 써야한다. 307, 308은 바꿀 수 있지만 얘는 무조건 써야됨. (일시 리다이렉션)
  * 304: Not Modified - 서버는 아무 데이터를 안 주는데(본문이 무조건 없어야 한다.) 캐시에 있는 데이터를 클라이언트가 알아서 쓰라는 코드 (특수 리다이렉션)
  * 307: Temporary Redirect - 302와 거의 똑같은데 302은 POST로 보내든 GET으로 보내든 서버에서 리다이렉션 요청을 하는 것은 GET방식으로 본문이 사라질 수 있다. 하지만 307은 처음 요청된 메서드와 같은 메서드로 본문을 포함해서 리다이렉션 요청을 보낼 수 있다. (일시 리다이렉션)
  * 308: Permanent Redirect - 301과 거의 똑같은데 301은 POST로 보내든 GET으로 보내든 서버에서 리다이렉션 요청을 하는 것은 GET방식으로 본문이 사라질 수 있다. 하지만 308은 처음 요청된 메서드와 같은 메서드로 본문을 포함해서 리다이렉션 요청을 보낼 수 있다. (영구 리다이렉션)
* 4xx - 클라이언트 오류
  * 400: 클라이언트 오류
  * 401: Unauthorized - 클라이언트가 서버에 인증되지 않음
  * 403: Forbbiden - 요청을 이해했지만 인증 계급이 낮음
  * 404: Not Found - 요청 리소스를 찾을 수 없음
  * 424: Failed Dependency - 클라이언트의 요청 리소스를 인식할 수 없음
* 5xx - 서버 오류
  * 500: 서버오류
  * 503: Service Unavailable - 서버가 일시적인 과부하나 예정된 작업으로 인해 사용 불가



## HEADER

### 일반 HEADER 종류

* Genernal Header: 메세지 전체에 적용되는 정보 - ex) Connection
* Request Header: 요청 정보 - ex) User-Agent
* Response Header: 응답 정보 - ex) Server
* Entity Header: 엔티티 바디 정보 - ex) Content-Type, Content-Length
  * Entity Body에 어떠한 데이터를 넣고 해당 데이터를 해석하기 위한 정보
  * RFC2616 -> RFC7230~7235로 쪼개지면서 Entity라는 것이 사라지고 Representation(표현) 데이터로 만들어짐
  * 즉, Entity Header가 아닌 **Representation Header**라고 부르면 된다.
  * 전송, 응답에 둘 다 사용
  * 종류
    * Content-Type: 표현 데이터의 형식
    * Content-Encoding: 표현 데이터의 압축 방식
    * Content-Language: 표현 데이터의 자연 언어
    * Content-Length: 표현 데이터의 길이
* 협상 헤더
  * 해당 헤더는 요청 시에만 사용.
  * 협상 헤더를 보낼때는 퀄리티 밸류를 설정해서 보낼 수 있음.
    * 예) Accept-Language: ko;q=0.8,en-US;q=0.7 (q가 퀄리티 밸류가 됨)
  * 구체적인 접근일수록 먼저 찾는다.
    * text/*, text/plain 이라면 text/plain 부터 찾음.
  * Accept: 클라이언트가 선호하는 미디어 타입 전달
  * Accept-Charset: 클라이언트가 선호하는 문자 인코딩
  * Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
  * Accept-Language: 클라이언트가 선호하는 자연 언어
* 전송 방식
  * 단순 전송
    * 한 번에 전송하고 한 번에 받는다.
  * 압축 전송
    * Content-Encoding에 압축된 방법 지정
    * 본문을 압축하고 클라이언트가 압축된 걸 풀어서 쓴다.
  * 분할 전송
    * Transfer-Encoding: chunked로 헤더 지정
    * 여러 청크로 쪼개서 보낸다.(ex. HLS)
    * Content-Length를 같이 보내지 않는다.
  * 범위 전송
    * Content-Range: bytes 1001-2000 / 2000
    * 위와 같이 끝 길이와 지금 보내는 범위에 대한 내용을 포함해서 보낸다.
* 정보성 헤더
  * 요청에서 사용
    * From: 유저 에이전트의 이메일 넣어 놓을 때
    * Referer: 어떤 사이트에서 지금 사이트를 들어왔는가? (유입경로)
    * User-Agaent: 클라이언트 어플리케이션 정보 - 특정브라우저의 장애 파악가능
  * 응답에서 사용
    * Server: 진짜 내 요청을 받는 서버(end단)
    * Date: 현재 시간
* 특별한 정보 헤더
  * Host: 요청한 호스트(서버 루트) 정보
  * Location: 3xx대의 리다이렉트 주소, 201에도 쓰긴하는데 거의 안 씀.
  * Allow: 어떤 HTTP 메서드를 허용하는가.
  * Retry-After: 날짜아니면 초단위로 표기
    * 503(Service Unavailable) 서비스가 언제까지 불능인지 알려줄 수 있음.
* 인증 헤더
  * Authorization: 서버에 전달할 클라이언트 인증정보
    * 여러가지가 있음.
  * WWW-Authenticate: 리소스 접근시 인증 방법을 표기
    * 어떠한 인증정보를 만들지 설명하는 헤더
* 쿠키 헤더
  * Set-Cookie: 서버에서 클라이언트로 쿠키를 전달한다(응답)
  * Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달한다.
  * 쿠키는 서버에 요청할 때, 자동적으로 헤더에 추가된다.
  * max-age, expires를 통해 쿠키의 만료일자를 지정가능
  * 지정하지 않으면 세션 쿠키로써 웹 브라우저가 켜져 있을 때까지만 존재.
  * domain을 지정가능(지정하지 않으면 해당 도메인(example.com)에서만 사용가능, 하면 dev.example.com 처럼 앞의 루트도 붙이기 가능) / 패스도 지정가능
  * HttpOnly - 자바스크립트에서 접근 불가.
  * Secure - https인 경우에만 전송
  * SameSite - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송가능 (해당부분은 디폴트로 되어있는 경우가 있음.)



### 캐시와 조건부 요청

* 캐시를 쓰는 이유
  * 캐시 가능 기간동안 네트워크 사용 X
  * 속도 상승
* 캐시 시간 설정 가능 - ex) cache-control: max-age=60; -> 캐시 시간 60초

* 검증 헤더
  * 캐시 시간이 지나면 서버에서 새로운 데이터를 가져와야 하지만, 데이터가 변경되지 않았을 경우에 데이터를 새로 받을 필요가 없다. 이 때, 조건부 요청(검증 헤더)이 추가된다.
  * 검증 헤더에 데이터 최종 수정일을 가지고 있다가 서버의 최종 수정일이랑 같으면 캐시 기간이 만료되었더라도 클라이언트의 캐시 데이터를 쓴다.
  * 검증 방식: if-modified-since(if-modifed)
    * 1초 미만 단위로 캐시 불가능
    * 날짜 기반의 로직 사용
    * 같은 데이터가 수정되서 같은 결과인 경우 검증 불가
    * 별도의 캐시 로직을 만들 수 없음
    * 요청헤더에 if-modified-since: 2021.11.25 11:11:11 추가 -> 응답으로 304 Not Modified 보내면서 body는 없음 (응답을 받은 클라이언트는 만료된 캐시데이터를 다시 세팅)
  * 검증 방식: ETag
    * if-modified-since의 단점을 개선
    * ETag 안에 파일의 Hash 값이나 버전을 설정
    * 요청헤더에 ETag: v1.0 추가 -> 응답으로 304 Not Modified 보내면서 body는 없음 (응답을 받은 클라이언트는 만료된 캐시데이터를 다시 세팅)
  * 깨알 팁
    * 개발자도구에서 보이는 회색 status 200은 캐시 데이터에서 가져온 것이다.
* 캐시 제어 헤더 종류
  * Cache-Control
    * max-age(초단위)
    * no-cache - origin 서버에 검증하고 사용(원서버가 오류일 경우 예전 캐시 데이터가 뜸)
    * must-revalidate - origin 서버에 검증하고 사용(원서버가 오류일 경우 504 Gateway Timeout 뜸)
    * no-store - 민감한 정보가 있으니 저장하지 말고 사용
    * expires(max-age의 하위호환 - max-age 사용 권장)
  * 검증 헤더
    * ETag
    * Last-Modified
  * 조건부 요청 헤더
    * If-Match, If-None-Match - ETag 값 사용
    * If-Modified-Since, If-Unmodified-Since - Last-Modified 값 사용
* 프록시 캐시
  * 프록시 서버가 origin 서버의 데이터들을 캐시해놓고 요청하는 곳에 바로 보내준다.
  * 이렇게 하는 이유는 origin서버(ex. 미국)가 멀 경우, 많은 시간이 걸릴텐데 가까운 곳에 프록시 서버(ex. 한국)를 만들어서 사용자에게 빠르게 응답할 수 있도록 한다.
  * Cache-Control
    * public(응답이 프록시 서버에 저장되어도 됨)
    * private(응답이 각 사용자들을 위한 캐시임. 즉, 클라이언트에 저장되어야 함)
    * s-maxage(초단위)
* 확실한 캐시 무효화 응답
  * Cache-Control: no-cache, no-store, must-revalidate + Pragma: no-cache(하위 호환을 위함)

<br/>
